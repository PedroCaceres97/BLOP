/**
 * @file pool.h
 * @brief Simple tracked allocation pool — header-only, optionally implemented per-translation-unit.
 *
 * This documentation describes the public contract and internal design of the
 * allocation pool implemented by pool.h. The pool is a thin wrapper around
 * malloc/free semantics that attaches a small header to every allocated block
 * and keeps a list of outstanding allocations so callers can:
 *  - Free individual allocations by pointer,
 *  - Free all allocations at once,
 *  - Query total allocated bytes and allocation count,
 *  - Duplicate or reallocate tracked allocations.
 *
 * The implementation is intended for debugging, deterministic lifetime
 * management (e.g. scoped subsystems), and leak detection. It is not a
 * general-purpose allocator replacement (no pooling of freed blocks,
 * no alignment guarantees beyond malloc).
 *
 * @remark Dependencie: blop/list.h
 *
 * @warning ## Thread Safety
 * **This pool implementation is *NOT* thread-safe.**
 * - Concurrent use requires external synchronization.
 * - No internal locking or atomic operations are performed.
 *
 * @version 1.0.0
 * @author Pedro Caceres
 * @date November 2025
 */

/* -------------------------------------------------------------------------- */
/*                                CONFIGURATION                                */
/* -------------------------------------------------------------------------- */

/**
 * @defgroup pool_configuration Configuration
 * @ingroup blop_pool
 * @brief Compile-time flags and symbol generation options.
 * @{
 */

/**
 * @name Configuration
 * @{
 */

/**
 * @def BLOP_POOL_NAME
 * @brief Unique tag used to generate all pool-related symbols.
 *
 * Determines:
 * - typedef name (`blopt_pool`) and auxiliary typedefs (prefixed/suffixed).
 * - generated function names (`<name>_create`, `<name>_malloc`, ...).
 *
 * @note Default: `poolb`
 * @remark Change the name to declare multiple independent pool types in the
 *         same program (each must have a single implementation definition).
 */

/**
 * @def BLOP_POOL_IMPLEMENTATION
 * @brief Enable implementation of pool functions in this translation unit.
 *
 * Must be defined exactly once for each unique ::BLOP_POOL_NAME.
 */

/** @} */ /* end of Configuration name */

/** @} */ /* end of pool_configuration */

/* -------------------------------------------------------------------------- */
/*                          STRUCTURES / TYPEDEFS                              */
/* -------------------------------------------------------------------------- */

/**
 * @defgroup pool_structures Structures and Typedefs
 * @ingroup blop_pool
 * @brief Opaque handles and internal layout.
 * @{
 */

/**
 * @typedef blopt_pool
 * @brief Opaque pointer to the pool structure.
 *
 * User code manipulates pools via this handle only.
 */

/**
 * @typedef blopt_ptrhdr
 * @brief Opaque pointer to the per-allocation header structure.
 *
 * Visible when ::BLOP_POOL_IMPLEMENTATION is defined.
 */

/**
 * @struct blops_ptrhdr
 * @brief Per-allocation header placed immediately before the pointer returned to user.
 *
 * Fields (visible when implementation is compiled):
 * - size_t size   — user-visible payload size in bytes.
 * - blopt_pool pool — owning pool pointer (for validation).
 * - struct blops_pool_list_node node — intrusive list node referencing this header.
 *
 * @remark The user pointer returned by pool_malloc/pool_calloc/etc points at
 *         the byte immediately after this header. The header is recovered with
 *         pointer arithmetic macros (BLOP_PSUB/BLOP_PADD).
 */

/**
 * @struct blops_pool
 * @brief Concrete pool structure (visible when implementation defined).
 *
 * Fields:
 * - size_t bytes      — total bytes currently allocated (sum of sizes tracked).
 * - struct blops_pool ptrs — intrusive list of outstanding allocation headers.
 *
 * @remark The list type used internally is a re-instantiation of list.h with
 *         BLOP_LIST_DATA_TYPE == void* and name derived from the pool name.
 */

/** @} */ /* end of pool_structures */

/* -------------------------------------------------------------------------- */
/*                                    API                                       */
/* -------------------------------------------------------------------------- */

/**
 * @defgroup pool_api Pool API
 * @ingroup blop_pool
 * @brief Allocation, deallocation, duplication, reallocation and diagnostics.
 * @{
 */

/**
 * @name Pool API
 * @{
 */

/**
 * @fn blopt_pool blopfn_pool_create()
 * @brief Create and initialize a new allocation pool.
 *
 * **Ownership:** Caller owns the returned pool and must destroy it with
 * ::blopfn_pool_destroy after ensuring all allocations were freed or the pool
 * was emptied with ::blopfn_pool_free_all.
 *
 * **Complexity:** O(1)
 *
 * @return Valid pool handle, or NULL on allocation failure.
 */

/**
 * @fn void blopfn_pool_destroy(blopt_pool pool)
 * @brief Destroy a pool previously created with ::blopfn_pool_create.
 *
 * **Complexity:** O(1)
 *
 * @param pool Pool to destroy.
 *
 * @warning **Precondition:** The pool must be empty (no outstanding tracked
 * allocations).
 * @remark Use ::blopfn_pool_free_all to free all tracked allocations before
 * destroying the pool.
 */

/**
 * @fn void blopfn_pool_free(blopt_pool pool, void* ptr)
 * @brief Free a single tracked allocation previously returned by this pool.
 *
 * **Complexity:** O(1)
 *
 * @param pool Pool that owns the pointer.
 * @param ptr Pointer previously returned by ::blopfn_pool_malloc/calloc/duplicate/realloc.
 *
 * @warning The pointer must belong to the provided pool. The implementation
 * verifies the internal header's pool field and will assert/abort on mismatch.
 */

/**
 * @fn void blopfn_pool_free_all(blopt_pool pool)
 * @brief Free all allocations currently tracked by the pool.
 *
 * **Complexity:** O(n) where n is the number of outstanding allocations.
 *
 * @param pool Pool to operate on.
 *
 * @remark After this call:
 *  - pool->bytes is set to 0
 *  - pool->ptrs.size is 0
 *  - all per-allocation headers and payloads are released via free()
 */

/**
 * @fn void* blopfn_pool_malloc(blopt_pool pool, size_t size)
 * @brief Allocate `size` bytes and register the allocation in the pool.
 *
 * **Complexity:** O(1) amortized
 *
 * @param pool Owning pool.
 * @param size Number of bytes requested (must be > 0).
 * @return Pointer to size bytes of memory, or NULL on failure.
 *
 * @behavior The implementation allocates header + payload, zeroes the block,
 * stores size and pool in the header, pushes the header into the pool's list,
 * increments pool->bytes, and returns pointer = header + sizeof(header).
 */

/**
 * @fn void* blopfn_pool_calloc(blopt_pool pool, size_t count, size_t size)
 * @brief Allocate `count * size` bytes and register the allocation in the pool.
 *
 * **Complexity:** O(1) amortized
 *
 * @param pool Owning pool.
 * @param count Number of elements.
 * @param size  Size of each element.
 * @return Pointer to allocated zeroed memory, or NULL on failure.
 *
 * @note The function multiplies count * size and treats the product as the
 * requested allocation size (subject to overflow in caller-provided types).
 */

/**
 * @fn void* blopfn_pool_realloc(blopt_pool pool, void* ptr, size_t size)
 * @brief Reallocate a tracked allocation to `size` bytes and register the new allocation.
 *
 * **Complexity:** O(n) in practice because a new allocation is performed and
 * memory is copied. The implementation does not attempt in-place resize.
 *
 * @param pool Owning pool.
 * @param ptr Pointer to existing tracked allocation (must belong to pool).
 * @param size New requested size in bytes (must be > 0).
 * @return Pointer to resized allocation (new pointer) or NULL on failure.
 *
 * @behavior A new tracked header+payload is allocated, the implementation copies
 * up to min(old_size, new_size) bytes from the old payload to the new payload,
 * zero-fills any newly allocated region, inserts the new header into the list
 * next to the old header, removes the old header from the list, adjusts
 * pool->bytes accordingly and frees the old header memory. The returned pointer
 * is the new payload pointer (header + sizeof(header)).
 */

/**
 * @fn void* blopfn_pool_duplicate(blopt_pool pool, void* ptr, size_t size)
 * @brief Create a new tracked allocation and copy `min(size, old_size)` bytes
 * from `ptr` into it.
 *
 * **Complexity:** O(min(size, old_size))
 *
 * @param pool Owning pool.
 * @param ptr Source pointer to copy from (must be tracked by same pool).
 * @param size Number of bytes to allocate for the duplicate.
 * @return Pointer to the duplicate payload, or NULL on failure.
 *
 * @remark The original allocation is kept intact; a new tracked allocation is
 * inserted immediately after the original in the internal list.
 */

/**
 * @fn void blopfn_pool_print(blopt_pool pool)
 * @brief Print a human-readable summary of the pool to stdout.
 *
 * **Complexity:** O(n)
 *
 * @param pool Pool to inspect.
 *
 * @note The function prints:
 *  - pool pointer and total bytes (pool->bytes)
 *  - number of tracked allocations
 *  - per-allocation pointer and size
 *
 * @warning The format is implementation-specific and intended for debugging.
 */

/**
 * @fn size_t blopfn_pool_get_bytes(blopt_pool pool)
 * @brief Get total bytes currently allocated through the pool.
 *
 * **Complexity:** O(1)
 *
 * @param pool Pool to query.
 * @return Sum of sizes of all outstanding allocations, or 0 if pool is NULL.
 */

/**
 * @fn size_t blopfn_pool_get_count(blopt_pool pool)
 * @brief Get number of outstanding tracked allocations.
 *
 * **Complexity:** O(1)
 *
 * @param pool Pool to query.
 * @return Number of allocations in the pool, or 0 if pool is NULL.
 */

/** @} */ /* end Pool API (name) */

/** @} */ /* end Pool API */

/* -------------------------------------------------------------------------- */
/*                                   EXAMPLES                                 */
/* -------------------------------------------------------------------------- */

/**
 * @defgroup pool_examples Examples
 * @ingroup blop_pool
 * @brief Usage patterns and examples.
 *
 * Example: create a pool, allocate, free, destroy:
 * @code{.c}
 * blopt_pool pool = poolb_create();
 * void* p1 = poolb_malloc(pool, 128);
 * void* p2 = poolb_calloc(pool, 4, 32);
 * poolb_free(pool, p1);
 * poolb_free_all(pool); // frees p2
 * poolb_destroy(pool);
 * @endcode
 *
 * Example: reallocating and duplicating:
 * @code{.c}
 * blopt_pool pool = poolb_create();
 * char* s = poolb_malloc(pool, 20);
 * strcpy(s, "hello");
 * s = poolb_realloc(pool, s, 40);        // s now points to a new tracked block
 * char* copy = poolb_duplicate(pool, s, 40);
 * poolb_free(pool, s);
 * poolb_free(pool, copy);
 * poolb_destroy(pool);
 * @endcode
 *
 * Example: diagnostics:
 * @code{.c}
 * blopt_pool pool = poolb_create();
 * void* a = poolb_malloc(pool, 64);
 * void* b = poolb_malloc(pool, 32);
 * poolb_print(pool);                  // prints two allocations and total bytes
 * size_t bytes = poolb_get_bytes(pool); // 96
 * size_t count = poolb_get_count(pool); // 2
 * poolb_free_all(pool);
 * poolb_destroy(pool);
 * @endcode
 */

/** @} */ /* end pool_examples */

/* -------------------------------------------------------------------------- */
/*                             DOCUMENTATION FOOTER                             */
/* -------------------------------------------------------------------------- */

/**
 * @copyright
 * This documentation is distributed under the same license as the project source.
 */
```//