/*
===============================================================================
BLOP - [Module Name]
-------------------------------------------------------------------------------
Documentation template and writing guide for module-specific documentation.
-------------------------------------------------------------------------------
Metadata:
 - Module name: short canonical name used in code (e.g. list, vector, pool)
 - Version: semantic or date-based doc version
 - Status: experimental | stable | deprecated
 - Dependencies: blop.h, other modules
-------------------------------------------------------------------------------
Table of Contents
  1. First Overview
  2. API conventions and public types
  3. Macros, how to fit your needs
  4. Memory and ownership
  5. Error handling and safe-mode behavior
  6. Thread-safety
  7. Common usage patterns and examples
  8. Troubleshooting and common mistakes
  9. Extensive internal documentation
===============================================================================

1) First Overview
  - Purpose:  give a high-level summary of the module for new users.
              It starts with a brief, engaging introduction to capture interest,
              then explains what the module does, its scope, and key features.

    Here´s the README.md as an example for the first overview section:
      # BLOP
      BLOP – Bizarre Logic & Odd Procedures (Only headers modules)

      ## Introduction
      “Long ago, in the dark ages of computing, there was only chaos.
      Code was scattered, functions wandered aimlessly, and programmers wept.
      Then came BLOP — a mysterious artifact, forged in the fires of countless debug sessions.”

      BLOP is not just a library.
      It is The Library — a timeless collection of completely unrelated modules,
      gathered over decades (or maybe hours, no one knows) by developers who
      refused to let their strange, misplaced code die.

      Some say BLOP was discovered on a dusty floppy disk labeled “DO NOT OPEN.”
      Others claim it was generated by a rogue AI in 1983.
      All we know is this: BLOP has survived operating system wars, language trends,
      and at least one full rewrite in C for reasons still unknown.

      Some also say BLOP stands for Bizarre Logic & Odd Procedures.
      Others also claim it’s just the sound your brain makes when it runs out of stack space.
      The truth has been lost to corrupted hard drives and mysterious Git commits.

      ## Purpose

      BLOP has no singular purpose.
      It exists to store everything that doesn’t belong anywhere else:
      algorithms you can’t categorize, functions you wrote at 3 AM,
      and utilities so oddly specific they’ll probably never be used again.
      Yet somehow, BLOP always finds a way to be useful.

      ## Core Principles

      1) Embrace the Weird    – No function is too strange for BLOP.
      2) Chaos is Consistency – The only standard is having no standard.
      3) Survive Anything     – BLOP will outlive you, me, and possibly the internet.

      ## Warning

      BLOP does not follow modern software design principles.
      BLOP is a principle — one of pure, unfiltered usefulness wrapped in absurdity.
      If you add to BLOP, you’re part of its history. Forever."

  Layout:
    1. Brief, engaging introduction as shown before (2-3 paragraphs).
    2. What the module does, its scope, and key features (3-5 paragraphs).
    3. Any high-level design principles or philosophies guiding the module.

2) API conventions and public types
  - Purpose:  explain naming conventions, data types, and general API design
              principles used in the module.
  - Layout:
    1. Naming conventions: function prefixes/suffixes, type naming patterns.
    2. Public types: structs, enums, typedefs used in the API.
    3. API design principles: error handling, memory management, thread-safety.

  - Note: The filosofy of BLOP is to keep things simple and straightforward.
          If you enable safe-mode, the module will perform extra checks and validations
          and always exit on error. But if not it will assume the caller knows 
          what they are doing and dont do shit to maximize performance.
          Almost all errors are undefined behavior unless safe-mode is enabled.
          You can be sure any function returning a pointer will return NULL on failure,
          but in any other case the return value does not relate to an error. 
          (Add examples of this with examples of the particuar module).

3) Macros, how to fit your needs
 - Purpose: explain all preprocessor macros, compile-time configuration
   points, and how they change the API or behavior.

 - For EVERY SINGLE macro provide next structure in this exact format:
   - Macro: [name of the macro]
   - Default: [default value if any]
   - Type: [What is supposed to define, a c data type, a function, a boolean flag]
   - Explanation: [What the macro does, what it affects, and how it changes behavior]
   - Notes: [Any special notes, caveats, or interactions with other macros] 

 - Always include this macros info no matter the module:
   - Macro: BLOP_SAFE_MODE
     Default: not defined
     Type: Boolean flag
     Explanation: Enables extra runtime checks and validations for safer usage.
     Notes: When enabled, functions will perform bounds checking and null
            pointer validations, potentially impacting performance.

   - Macro: BLOP_EXIT_ON_ERROR
     Default: not defined
     Type: Boolean flag
     Explanation: Whenever an error is detected it will use exit(-1).
     Notes: It allows the use of atexit().

   - Macro: BLOP_ABORT_ON_ERROR
     Default: not defined
     Type: Boolean flag
     Explanation: Whenever an error is detected it will use abort().
     Notes: Useful for debugging as it generates a core dump.

4) Memory and ownership
 - Purpose: make ownership semantics explicit so callers know who must free
            what and when. This has to be very tecnical and precise, jokes aside.

 - Layout: 
  1. General BLOP rules about memory ownership (Literal copy-paste except these brackets): 
      You call a function to create and then you call a function to destroy it, 
      you never call malloc or free directly. 
      If a function returns a pointer you own it unless otherwise stated.

  2. For every function that allocates, deallocates or may provide this functionality 
     through their paramaters describe:
     - Signature (exact prototype).
     - What activates allocation/deallocation (only in case where the function may but not necessesarily do).
     - Who owns the returned memory (caller or module).
     - How to deallocate it (free, module-specific free function).
     - Alternative functionality or similar function (only if any)

What to write:
 - For each "create"/"alloc" function include a short sentence: "Returns an
   owned pointer. Caller must free using X when finished."
 - For "get" accessors: state whether they return internal pointers (do not
   modify) or copies.
 - If the module uses internal pools or arenas, explain their semantics,
   quotas, and how to reset them.

5) Error handling and safe-mode behavior
 - Purpose: show how failures are reported and how the module behaves in
   debug vs safe vs release builds.
 - Describe:
   - Error reporting model (return codes, errno, callbacks, logging).
   - Standard error codes and their meaning for the module (list canonical
     values).
   - Assertions and abort behavior: whether the module aborts on invariant
     violations, and how to disable that (compile flag).
   - How to enable verbose diagnostics or logging, and where messages go
     (stderr, custom logger).
   - How to detect and handle recoverable vs non-recoverable errors.

What to write:
 - Provide concrete examples for checking errors:
   - Example showing how to check return value and interpret error code.
   - Explain default safe behavior and how to opt-out for performance.

6) Thread-safety
 - Purpose: state concurrency guarantees and the thread-safety model, 
   if the module its not thread-safety make a big warning about it.
 - For each API surface indicate:
   - Completely thread-safe functions (concurrent calls safe).
   - Functions that require external synchronization (caller must lock).
   - Reentrancy guarantees (whether a function can be called from inside
     callbacks).
 - If the module provides optional thread-safe variants (macros), explain
   how to enable them and the performance tradeoffs.
 - Guidelines for locking strategy when mixing this module with others.

What to write:
 - A short paragraph summarizing global safety (e.g. "module is not
   thread-safe by default").
 - Then bullet list mapping types/functions to safety category.
 - Provide a minimal recommended pattern for safe usage (lock before use or
   use thread-safe wrapper).

7) Common usage patterns and examples
 - Purpose: provide concise, copy-pasteable examples of typical uses.
 - Include 3–6 examples that cover:
   - Initialization and teardown (required steps and order).
   - Short "hello-world" usage: create, use, destroy.
   - One example showing an error case and how to handle it.
   - One example showing efficient/advanced usage (batching, pooling) if
     applicable.
   - Minimal example showing memory ownership in practice.
 - Each example should include:
   - Code snippet (small, 10–20 lines), annotated with comments on important
     lines and why choices are made.
   - A short explanation of the snippet's purpose and any caveats.

What to write:
 - For each snippet, show only the API calls and minimal setup — no internal
   data. Use placeholders like "module_create(...)" not real internals.
 - Prefer clarity over completeness in examples; link to full examples if
   available externally.

8) Troubleshooting and common mistakes
 - Purpose: prevent and fix the most likely integration errors.
 - Include:
   - Top 6–8 pitfall bullets: misuse patterns, off-by-one, forgetting to call
     destroy, wrong macro ordering, pointer ownership mistakes.
   - Error messages and their likely causes (map message -> cause -> fix).
   - Debugging tips: how to enable internal checks, what to log, what to
     assert in the caller to trap misuse earlier.
   - Performance pitfalls: common operations that are expensive and how to
     make them cheaper.
 - Provide command-line tips or small tools to help debug (e.g. valgrind,
   sanitizer flags) and recommended compiler flags for maximum safety.

What to write:
 - List concrete symptoms and steps to reproduce; then give prescriptive fixes.
 - For each performance or memory leak symptom give the probable cause and
   a short remedy.

9) Extensive internal documentation
 - Purpose: in depth explanation for all public and private functions, types and macros.
 - For each function/macro/type provide:
   - Signature (exact prototype).
   - One-line summary (what it does).
   - Parameters: name, type, required? allowed values, and whether caller owns.
   - Return value: meaning of each return value, error codes, sentinel values.
   - Thread-safety and reentrancy note (one-line).
   - Side effects (mutates global state, alters input).
   - Example usage (1–2 lines) if non-trivial.
 - Order the reference consistently: constructors/destructors first, then
   accessors, then utilities.
 - For macros: default value, effect, and evaluation order caveats.
 - For types: document size/alignment guarantees if relevant.

What to write:
 - Use a regular, machine-parsable format if possible (e.g. short headings per
   symbol). Example canonical block for a function:
     Function: foo_create
     Prototype: foo_t* foo_create(int capacity)
     Summary: Allocates and returns an owned foo_t with initial capacity.
     Params: capacity — initial capacity (>=1). If 0, default applied.
     Returns: owned pointer or NULL on allocation failure.
     Thread-safety: not thread-safe; call under external lock.
     Side-effects: allocates memory, registers the object in internal table.

Checklist for writers (AI and humans)
 - Metadata present and correct.
 - Overview concise and accurate.
 - All macros described with defaults and examples.
 - Ownership rules explicit for every allocation/copying operation.
 - Error model and assertions explained, with examples to check for errors.
 - Thread-safety table present.
 - At least three examples covering create/use/destroy and one error case.
 - Reference covers every exported symbol and its contract.
 - Troubleshooting lists top 6–8 real-world issues and fixes.

===============================================================================
End of documentation block
===============================================================================
*/