/**
 * @file list.h
 * @brief Typed intrusive doubly-linked list — header-only, macro-configurable.
 *
 * This header implements an intrusive, doubly-linked list that provides full
 * type-safety, low overhead, and explicit control over node ownership.
 * It is intended to be re-included with different macro configurations to
 * generate distinct list types at compile time.
 *
 * ## Key Features
 * - **Intrusive nodes**: user data lives *inside* each node, eliminating
 *   allocations of separate wrapper objects.
 * - **Header-only**: define ::BLOP_LIST_IMPLEMENTATION exactly once to generate
 *   the function bodies.
 * - **Configurable types**:
 *      - ::BLOP_LIST_NAME for prefix/suffix symbol generation.
 *      - ::BLOP_LIST_DATA_TYPE for stored element type.
 *      - ::BLOP_LIST_DEALLOCATE_DATA for optional custom deallocation.
 *
 * @warning ## ⚠ Thread Safety
 * **This list implementation is *NOT* thread-safe.**
 * - Simultaneous access from multiple threads requires external synchronization.
 * - No internal locking is performed.
 *
 * @version 1.0.0
 * @author Pedro Caceres
 * @date November 2025
 */

/* -------------------------------------------------------------------------- */
/*                               CONFIGURATION                                */
/* -------------------------------------------------------------------------- */

/**
 * @defgroup list_configuration Configuration
 * @ingroup blop_list
 * @brief Compile-time flags controlling list behavior and symbol generation.
 * @{
 */

/**
 * @name Configuration
 * @brief Compile-time flags controlling list behavior and symbol generation.
 * @{
 */

/**
 * @def BLOP_LIST_NAME
 * @brief Unique tag used to generate all list-related symbols.
 *
 * Determines the names of:
 * - typedefs (`blopt_list`, `blopt_node`)
 * - list/node structure names
 * - all generated functions prefixed with BLOP_LIST_NAME_*
 *
 * @note Default: `listb`
 * @remark Choose a different name to declare multiple independent list types
 *         in the same program.
 */

/**
 * @def BLOP_LIST_DATA_TYPE
 * @brief Data type stored inside each node.
 *
 * Allows storing any type without `void*` casting.
 *
 * @remark If storing heap-allocated data inside the node, consider defining
 * ::BLOP_LIST_DEALLOCATE_DATA so data is properly freed on node destroy.
 *
 * @note Default: `uint8_t`
 */

/**
 * @def BLOP_LIST_DEALLOCATE_DATA(ptr)
 * @brief Callback invoked to deallocate node->data during node destruction.
 *
 * Typical signature:
 * @code{.c}
 * void my_deallocator(BLOP_LIST_DATA_TYPE* ptr)
 * @endcode
 *
 * @remark If undefined, no data deallocation is performed.
 */

/**
 * @def BLOP_LIST_IMPLEMENTATION
 * @brief Enable implementation of list functions in this compilation unit.
 *
 * Must be defined **exactly once** per unique ::BLOP_LIST_NAME.
 */

/** @} */ /* end of list_configuration (name) */

/** @} */ /* end of list_configuration */

/* -------------------------------------------------------------------------- */
/*                          STRUCTURES / TYPEDEFS                             */
/* -------------------------------------------------------------------------- */

/** 
 * @defgroup list_structures Structures and Typedefs
 * @ingroup blop_list
 * @brief Opaque pointers and concrete structures
 * @{
 */

/**
 * @typedef blopt_list
 * @brief Opaque pointer to the list structure.
 *
 * User code interacts with lists exclusively through this handle.
 */

/**
 * @typedef blopt_node
 * @brief Opaque pointer to the node list structure.
 *
 * User code interacts with nodes exclusively through this handle.
 */

/**
 * @struct blops_list
 * @brief Concrete list structure
 * @warning visible only when ::BLOP_LIST_IMPLEMENTATION defined.
 */

/** 
 * @var size_t blops_list::size
 * @brief Number of nodes.
 */

/** 
 * @var blopt_node blops_list::front
 * @brief Front node or NULL.
 */


/** 
 * @var blopt_node blops_list::back
 * @brief Back node or NULL.
 */

/**
 * @struct blops_node
 * @brief Concrete node structure
 * @warning visible only when ::BLOP_LIST_IMPLEMENTATION defined.
 */

/** 
 * @var BLOP_LIST_DATA_TYPE blops_node::data
 * @brief Stored element.
 */

/**
 * @var blopt_node blops_node::next
 * @brief Next node in list (NULL if none).
 */

/**
 * @var blopt_node blops_node::prev
 * @brief Previous node in list (NULL if none).
 */

/**
 * @var blopt_list blops_node::list
 * @brief Owning list (NULL if unlinked).
 */

/** @} */ /* end of list structures */

/* -------------------------------------------------------------------------- */
/*                                 List API                                   */
/* -------------------------------------------------------------------------- */

/**
 * @defgroup list_api List API
 * @ingroup blop_list
 * @brief Main operations for creation, insertion, deletion, and traversal.
 *
 * @warning **Thread Safety**  
 * None of the functions are thread-safe.  
 * Caller must handle synchronization when used concurrently.
 *
 * @{
 */

/**
 * @name List API
 * @brief Main operations for creation, insertion, deletion, and traversal.
 *
 * @warning **Thread Safety**  
 * None of the functions are thread-safe.  
 * Caller must handle synchronization when used concurrently.
 *
 * @{
 */

/**
 * @fn blopt_list blopfn_list_create()
 * @brief Create and initialize a new empty list.
 *
 * **Ownership:**  
 * Caller owns the returned list and must eventually destroy it with
 * ::blopfn_list_destroy.
 *
 * **Complexity:** O(1)
 *
 * @return Valid list handle, or NULL on allocation failure.
 */

/**

/**
 * @fn void blopfn_list_destroy(blopt_list list)
 * @brief Destroy a list previously created with ::blopfn_list_create.
 *
 * **Complexity:** O(1)
 *
 * @param list List to destroy.
 *
 * @warning **Precondition:** The list must be empty (`size == 0`).
 * @warning **Ownership:** Frees the list structure itself. Does *not* free nodes or their data.
 * @remark Use ::blopfn_list_clear to remove and optionally deallocate nodes first.
 */

/**
 * @fn blopt_node blopfn_list_get_front(blopt_list list)
 * @brief Return the first node of the list.
 *
 * **Complexity:** O(1)
 *
 * @param list List to query.
 * @return Node pointer or NULL if empty.
 * @remark Querying from an empty container will not result in an error
 */

/**
 * @fn blopt_node blopfn_list_get_back(blopt_list list)
 * @brief Return the last node of the list.
 *
 * **Complexity:** O(1)
 *
 * @param list List to query.
 * @return Node pointer or NULL if empty.
 * @remark Querying from an empty container will not result in an error
 */

/**
 * @fn size_t blopfn_list_get_size(blopt_list list)
 * @brief Get the number of nodes in the list.
 *
 * **Complexity:** O(1)
 *
 * @param list List to query.
 * @return Node count, or 0 if list is NULL.
 */

/**
 * @fn blopt_node blopfn_list_get_node(blopt_list list, size_t index)
 * @brief Return node at a given index.
 *
 * Optimized to traverse from the closest edge (front or back),
 * so the real cost is O(min(index, n - index)).
 * Worst case is O(n/2) so formal Big-O notation is O(n).
 * 
 * **Complexity:** O(n)
 *
 * @param list List to search.
 * @param index Zero-based index (0..n-1).
 * @return Node pointer or NULL if out of bounds.
 */

/**
 * @fn void blopfn_list_clear(blopt_list list, int deallocate)
 * @brief Remove all nodes from the list.
 *
 * **Complexity:** O(n)
 *
 * **Ownership rules:**  
 * - If `!deallocate`: nodes are unlinked but **not destroyed**. Caller remains owner and must manually destroy them.  
 * - If `deallocate`:  
 *      - Nodes are unliked and destroyed using ::blopfn_node_destroy  
 *      - If ::BLOP_LIST_DEALLOCATE_DATA is defined, data is freed too.
 *
 * @param list List to clear.
 * @param deallocate Whether to destroy nodes after unlinking.
 */

/**
 * @fn void blopfn_list_erase(blopt_list list, blopt_node node, int deallocate)
 * @brief Remove a specific node from the list.
 *
 * **Complexity:** O(1)
 *
 * **Ownership rules:**  
 * - If `!deallocate`: node is unlinked but **not destroyed**. Caller remains owner and must manually destroy it.  
 * - If `deallocate`:
 *      - Node is unliked and destroyed using ::blopfn_node_destroy  
 *      - If ::BLOP_LIST_DEALLOCATE_DATA is defined, data is freed too.
 *
 * @param list List containing the node.
 * @param node Node to remove.
 * @param deallocate Whether to destroy node after unlinking.
 * @warning If the node does not belong to the list an error will be produced
 */

/**
 * @fn void blopfn_list_pop_back(blopt_list list, int deallocate)
 * @brief Remove the last node.
 *
 * **Complexity:** O(1)
 *
 * **Ownership rules:**  
 * - If `!deallocate`: node is unlinked but **not destroyed**. Caller remains owner and must manually destroy it.  
 * - If `deallocate`:
 *      - Node is unliked and destroyed using ::blopfn_node_destroy  
 *      - If ::BLOP_LIST_DEALLOCATE_DATA is defined, data is freed too.
 *
 * @param list List to pop.
 * @param deallocate Whether to destroy node after unlinking.
 * @warning Popping from an empty container will result in an error.
 * @see ::BLOP_VALID_EMPTY_POPPING
 */

/**
 * @fn void blopfn_list_pop_front(blopt_list list, int deallocate)
 * @brief Remove the first node.
 *
 * **Complexity:** O(1)
 *
 * **Ownership rules:**  
 * - If `!deallocate`: node is unlinked but **not destroyed**. Caller remains owner and must manually destroy it.  
 * - If `deallocate`:
 *      - Node is unliked and destroyed using ::blopfn_node_destroy  
 *      - If ::BLOP_LIST_DEALLOCATE_DATA is defined, data is freed too.
 *
 * @param list List to pop.
 * @param deallocate Whether to destroy node after unlinking.
 * @warning Popping from an empty container will result in an error.
 * @see ::BLOP_VALID_EMPTY_POPPING
 */

/**
 * @fn void blopfn_list_push_back(blopt_list list, blopt_node node)
 * @brief Insert a node at the end of the list.
 *
 * **Complexity:** O(1)
 *
 * @param list List to insert the node into.
 * @param node Node to insert.
 * @warning Node must not already belong to another list.
 * @see ::blopfn_node_duplicate
 */

/**
 * @fn void blopfn_list_push_front(blopt_list list, blopt_node node)
 * @brief Insert a node at the start of the list.
 *
 * **Complexity:** O(1)
 *
 * @param list List to insert the node into.
 * @param node Node to insert.
 * @warning Node must not already belong to another list.
 * @see ::blopfn_node_duplicate
 */

/**
 * @fn void blopfn_list_insert_next(blopt_list list, blopt_node pivot, blopt_node node)
 * @brief Insert a node immediately after another.
 *
 * **Complexity:** O(1)
 *
 * @param list List to insert the node into.
 * @param pivot Node after which to insert.
 * @param node Node to insert.
 * @warning If the pivot does not belong to the provided list or the node already belong to another list an error will be produced.
 * @see ::blopfn_node_duplicate
 */

/**
 * @fn void blopfn_list_insert_prev (blopt_list list, blopt_node pivot, blopt_node node)
 * @brief Insert a node immediately before another.
 *
 * **Complexity:** O(1)
 *
 * @param list List to insert the node into.
 * @param pivot Node before which to insert.
 * @param node Node to insert.
 * @warning If the pivot does not belong to the provided list or the node already belong to another list an error will be produced.
 * @see ::blopfn_node_duplicate
 */

/** @} */ /* end List API (name) */

/** @} */ /* end List API */

/* -------------------------------------------------------------------------- */
/*                                 Node API                                   */
/* -------------------------------------------------------------------------- */

/**
 * @defgroup list_node_api Node API
 * @ingroup blop_list
 * @brief Node allocation, cloning, destruction, and field access.
 *
 * @warning **Thread Safety**  
 * Node operations are not thread-safe if they interact with a list.
 * Standalone nodes are safe as long as user code prevents data races.
 *
 * @{
 */

/**
 * @name Node API
 * @brief Node allocation, cloning, destruction, and field access.
 *
 * @warning **Thread Safety**  
 * Node operations are not thread-safe if they interact with a list.
 * Standalone nodes are safe as long as user code prevents data races.
 *
 * @{
 */


/**
 * @fn blopt_node blopfn_node_create()
 * @brief Allocate a new standalone node (not linked to any list).
 *
 * **Ownership:**  
 * Caller owns the node and must destroy it with ::blopfn_node_destroy
 * or by providing `deallocate == true` into any list erasing operation.
 *
 * **Complexity:** O(1)
 *
 * @return Newly allocated node, or NULL.
 */

/**
 * @fn blopt_node blopfn_node_duplicate(blopt_node node)
 * @brief Create a shallow copy of a node.
 *
 * **Data Handling:**  
 * - `data` is copied **by value**.  
 * - If data points to heap memory, pointer is copied — no deep clone.
 *
 * **Ownership:**  
 * Caller owns the node and must destroy it with ::blopfn_node_destroy
 * or by providing `deallocate == true` into any list erasing operation.
 *
 * **Complexity:** O(1)
 *
 * @param node Node to duplicate (must be non-NULL).
 * @return Duplicate node, never attached to a list.
 */

/**
 * @fn void blopfn_node_destroy(blopt_node node)
 * @brief Destroy a node not currently linked to any list.
 *
 * **Ownership rules:**  
 * - Frees the node object.
 * - If ::BLOP_LIST_DEALLOCATE_DATA is defined then 
 *   BLOP_LIST_DEALLOCATE_DATA(node->data) will be called to deallocate data.
 *
 * **Complexity:** O(1)
 *
 * @param node Node to destroy.
 * @warning **Precondition:** The list must be empty (`size == 0`).
 */

/**
 * @fn blopt_node blopfn_node_set_data(blopt_node node, BLOP_LIST_DATA_TYPE data)
 * @brief Set node data.
 * @param node Target node.
 * @param data Data value to store.
 * @return The same node pointer (for convenience / chaining), or NULL on error.
 */

/**
 * @fn BLOP_LIST_DATA_TYPE blopfn_node_get_data(blopt_node node)
 * @brief Get node data.
 * @param node Node to query.
 * @return Stored data, or 0 (cast) if node is NULL.
 */

/**
 * @fn blopt_node blopfn_node_get_next(blopt_node node)
 * @brief Get next node pointer.
 * @param node Node to query.
 * @return Next node or NULL.
 */

/**
 * @fn blopt_node blopfn_node_get_prev(blopt_node node)
 * @brief Get previous node pointer.
 * @param node Node to query.
 * @return Previous node or NULL.
 */

/** @} */ /* end of node api (name) */

/** @} */ /* end of node api */

/* -------------------------------------------------------------------------- */
/*                             DOCUMENTATION FOOTER                           */
/* -------------------------------------------------------------------------- */

/**
 * @copyright
 * This documentation is distributed under the same license as the project source.
 */