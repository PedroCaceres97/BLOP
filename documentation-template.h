/*
===============================================================================
BLOP - [Module Name]
-------------------------------------------------------------------------------
Documentation template and writing guide for module-specific documentation.
This template is intended for an AI (or human) that will produce the
module documentation that appears inside each module's header/source file.
It explains, in detail, what needs to appear in each numbered section of
the original template and how to write it so all modules share the same
conventions and completeness.
-------------------------------------------------------------------------------
Style notes (read before filling):
 - Write in plain, precise technical English. Prefer active voice.
 - Be consistent with terminology (use "owner" for memory ownership, "caller"
   for the code that invoked an API, etc.).
 - Use concrete examples and small code snippets where appropriate, but
   never include module-specific internals or actual implementation data.
 - Keep the "overview" a little inventive if you like, but the rest must be
   factual, structured and unambiguous.
 - Use lists and labeled subsections for easy scanning.
 - Include a minimal "metadata" block at the very top for automation tools.
-------------------------------------------------------------------------------
Required metadata (place at the top of every module doc produced from this template):
 - Module name: short canonical name used in code (e.g. MyModule)
 - Version: semantic or date-based doc version
 - Status: experimental | stable | deprecated
 - Dependencies: other modules, platform constraints, compiler features
 - Macros/flags that modify the API or behavior (list with brief meaning)
-------------------------------------------------------------------------------
Table of Contents
  1. First Overview
  2. Macros, how to fit your needs
  3. API conventions and public types
  4. Memory and ownership
  5. Error handling and safe-mode behavior
  6. Thread-safety
  7. Common usage patterns and examples
  8. Troubleshooting and common mistakes
  9. Extensive internal documentation
===============================================================================

1) First Overview
 - Purpose: An introduction that states what the module does,
   what problem(s) it solves, and its intended audience.
   It can be very creative, fun and engaging to read,
   do not make fake statements but try to hook the reader.
   Here´s the README.md as an example:
      # BLOP
      BLOP – Bizarre Logic & Odd Procedures (Only headers modules)

      ## Introduction
      “Long ago, in the dark ages of computing, there was only chaos.
      Code was scattered, functions wandered aimlessly, and programmers wept.
      Then came BLOP — a mysterious artifact, forged in the fires of countless debug sessions.”

      BLOP is not just a library.
      It is The Library — a timeless collection of completely unrelated modules,
      gathered over decades (or maybe hours, no one knows) by developers who
      refused to let their strange, misplaced code die.

      Some say BLOP was discovered on a dusty floppy disk labeled “DO NOT OPEN.”
      Others claim it was generated by a rogue AI in 1983.
      All we know is this: BLOP has survived operating system wars, language trends,
      and at least one full rewrite in C for reasons still unknown.

      Some also say BLOP stands for Bizarre Logic & Odd Procedures.
      Others also claim it’s just the sound your brain makes when it runs out of stack space.
      The truth has been lost to corrupted hard drives and mysterious Git commits.

      ## Purpose

      BLOP has no singular purpose.
      It exists to store everything that doesn’t belong anywhere else:
      algorithms you can’t categorize, functions you wrote at 3 AM,
      and utilities so oddly specific they’ll probably never be used again.
      Yet somehow, BLOP always finds a way to be useful.

      ## Core Principles

      1) Embrace the Weird    – No function is too strange for BLOP.
      2) Chaos is Consistency – The only standard is having no standard.
      3) Survive Anything     – BLOP will outlive you, me, and possibly the internet.

      ## Warning

      BLOP does not follow modern software design principles.
      BLOP is a principle — one of pure, unfiltered usefulness wrapped in absurdity.
      If you add to BLOP, you’re part of its history. Forever."

 - Scope: Short bullet list of what is inside the module and what is NOT
   inside (boundaries). For example: "Provides lightweight dynamic arrays.
   Does NOT provide thread-safe variants by default."
 - Requirements and constraints: runtime or compile-time constraints (e.g.
   requires C99, assumes little-endian only for the wire-format helpers,
   must be initialized before use).
 - Intended usage scenarios: 2–4 concise scenarios where the module shines.
 - Stability statement: whether the API is stable or experimental; whether
   breaking changes might be expected.
 - Tone guidance: this paragraph can be a tiny bit creative to engage the
   reader, but stay factual: no fictional metaphors in the detailed sections.

What to write:
 - Start with "This module ..." and follow with one clear sentence of intent.
 - Add 3–5 bullets: features, exclusions, platform constraints.
 - Add one line describing expected maturity and compatibility (ABI/semantic).
 - Avoid implementation details (no function names, no static internals).

2) Macros, how to fit your needs
 - Purpose: explain all preprocessor macros, compile-time configuration
   points, and how they change the API or behavior.
 - For every macro provide:
   - Macro name and default value.
   - Allowed values or formats and their meaning.
   - Whether the macro must be defined before including the header, or if
     it can be changed per translation unit.
   - Examples of common configurations (short, not module-specific).
 - Mention interactions: if Macro A affects Macro B or toggles features.
 - Mention safety macros that switch on "safe mode" or debug assertions.

What to write:
 - Present a table-like list: Macro — Default — Type — Effect — Notes.
 - Show one or two tiny code examples demonstrating how to override macros:
   e.g. #define MODULE_NAME MyModule before including header.

3) API conventions and public types
 - Purpose: document naming conventions, calling conventions, typedefs,
   and the set of public opaque types and handles.
 - Include:
   - Naming rules for types, functions and macros used by this project.
   - The public types (opaque structs, enums, typedefs) and a sentence
     describing their role. For opaque types state "opaque" and lifetime.
   - Function categories (create/destroy, accessors, mutators, helpers).
   - Argument nullability rules: which pointers may be NULL, and what that
     means.
   - Return value conventions: success codes, sentinel values, and whether
     functions return errors via errno, custom codes, or assert/abort.

What to write:
 - List every public type signature and one-line description (no internals).
 - Define how functions are named and grouped (prefixes/suffixes).

4) Memory and ownership
 - Purpose: make ownership semantics explicit so callers know who must free
   what and when.
 - For every allocation-returning function describe:
   - Who owns the returned memory (caller or module).
   - How to deallocate it (free, module-specific free function).
   - Whether the module provides pooled or borrowed pointers.
   - If memory is shared across calls or cached, note lifetime and thread
     constraints.
 - For input buffers or pointers:
   - Whether the module copies, borrows, or takes ownership.
   - Whether the module expects the buffer to be valid until some call.
 - Alignment and size guarantees.
 - Suggest recommended idioms: use helper destroy functions rather than free()
   when appropriate; prefer stack for small temporary objects.

What to write:
 - For each "create"/"alloc" function include a short sentence: "Returns an
   owned pointer. Caller must free using X when finished."
 - For "get" accessors: state whether they return internal pointers (do not
   modify) or copies.
 - If the module uses internal pools or arenas, explain their semantics,
   quotas, and how to reset them.

5) Error handling and safe-mode behavior
 - Purpose: show how failures are reported and how the module behaves in
   debug vs safe vs release builds.
 - Describe:
   - Error reporting model (return codes, errno, callbacks, logging).
   - Standard error codes and their meaning for the module (list canonical
     values).
   - Assertions and abort behavior: whether the module aborts on invariant
     violations, and how to disable that (compile flag).
   - How to enable verbose diagnostics or logging, and where messages go
     (stderr, custom logger).
   - How to detect and handle recoverable vs non-recoverable errors.

What to write:
 - Provide concrete examples for checking errors:
   - Example showing how to check return value and interpret error code.
   - Explain default safe behavior and how to opt-out for performance.

6) Thread-safety
 - Purpose: state concurrency guarantees and the thread-safety model, 
   if the module its not thread-safety make a big warning about it.
 - For each API surface indicate:
   - Completely thread-safe functions (concurrent calls safe).
   - Functions that require external synchronization (caller must lock).
   - Reentrancy guarantees (whether a function can be called from inside
     callbacks).
 - If the module provides optional thread-safe variants (macros), explain
   how to enable them and the performance tradeoffs.
 - Guidelines for locking strategy when mixing this module with others.

What to write:
 - A short paragraph summarizing global safety (e.g. "module is not
   thread-safe by default").
 - Then bullet list mapping types/functions to safety category.
 - Provide a minimal recommended pattern for safe usage (lock before use or
   use thread-safe wrapper).

7) Common usage patterns and examples
 - Purpose: provide concise, copy-pasteable examples of typical uses.
 - Include 3–6 examples that cover:
   - Initialization and teardown (required steps and order).
   - Short "hello-world" usage: create, use, destroy.
   - One example showing an error case and how to handle it.
   - One example showing efficient/advanced usage (batching, pooling) if
     applicable.
   - Minimal example showing memory ownership in practice.
 - Each example should include:
   - Code snippet (small, 10–20 lines), annotated with comments on important
     lines and why choices are made.
   - A short explanation of the snippet's purpose and any caveats.

What to write:
 - For each snippet, show only the API calls and minimal setup — no internal
   data. Use placeholders like "module_create(...)" not real internals.
 - Prefer clarity over completeness in examples; link to full examples if
   available externally.

8) Troubleshooting and common mistakes
 - Purpose: prevent and fix the most likely integration errors.
 - Include:
   - Top 6–8 pitfall bullets: misuse patterns, off-by-one, forgetting to call
     destroy, wrong macro ordering, pointer ownership mistakes.
   - Error messages and their likely causes (map message -> cause -> fix).
   - Debugging tips: how to enable internal checks, what to log, what to
     assert in the caller to trap misuse earlier.
   - Performance pitfalls: common operations that are expensive and how to
     make them cheaper.
 - Provide command-line tips or small tools to help debug (e.g. valgrind,
   sanitizer flags) and recommended compiler flags for maximum safety.

What to write:
 - List concrete symptoms and steps to reproduce; then give prescriptive fixes.
 - For each performance or memory leak symptom give the probable cause and
   a short remedy.

9) Extensive internal documentation
 - Purpose: in depth explanation for all public and private functions, types and macros.
 - For each function/macro/type provide:
   - Signature (exact prototype).
   - One-line summary (what it does).
   - Parameters: name, type, required? allowed values, and whether caller owns.
   - Return value: meaning of each return value, error codes, sentinel values.
   - Thread-safety and reentrancy note (one-line).
   - Side effects (mutates global state, alters input).
   - Example usage (1–2 lines) if non-trivial.
 - Order the reference consistently: constructors/destructors first, then
   accessors, then utilities.
 - For macros: default value, effect, and evaluation order caveats.
 - For types: document size/alignment guarantees if relevant.

What to write:
 - Use a regular, machine-parsable format if possible (e.g. short headings per
   symbol). Example canonical block for a function:
     Function: foo_create
     Prototype: foo_t* foo_create(int capacity)
     Summary: Allocates and returns an owned foo_t with initial capacity.
     Params: capacity — initial capacity (>=1). If 0, default applied.
     Returns: owned pointer or NULL on allocation failure.
     Thread-safety: not thread-safe; call under external lock.
     Side-effects: allocates memory, registers the object in internal table.

Checklist for writers (AI and humans)
 - Metadata present and correct.
 - Overview concise and accurate.
 - All macros described with defaults and examples.
 - Ownership rules explicit for every allocation/copying operation.
 - Error model and assertions explained, with examples to check for errors.
 - Thread-safety table present.
 - At least three examples covering create/use/destroy and one error case.
 - Reference covers every exported symbol and its contract.
 - Troubleshooting lists top 6–8 real-world issues and fixes.

===============================================================================
End of documentation block
===============================================================================
*/